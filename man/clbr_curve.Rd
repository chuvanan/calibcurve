% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calibration-curve.R
\name{calibration_curve}
\alias{calibration_curve}
\alias{calibration_curve.data.frame}
\alias{calibration_curve_vec}
\alias{autoplot.clbr_df}
\title{Calibration Curve}
\usage{
calibration_curve(data, ...)

\method{calibration_curve}{data.frame}(
  data,
  truth,
  ...,
  n_bins = 10L,
  scale_estimate = FALSE,
  discretise_strategy = c("uniform", "quantile"),
  na_rm = TRUE
)

calibration_curve_vec(
  truth,
  estimate,
  n_bins = 10L,
  scale_estimate = FALSE,
  discretise_strategy = c("uniform", "quantile"),
  na_rm = TRUE,
  ...
)

\method{autoplot}{clbr_df}(object, ...)
}
\arguments{
\item{data}{A \code{data.frame} containing the \code{truth} and \code{estimate} columns.}

\item{...}{Not currently used}

\item{truth}{The column identifier for the true class results (that is a
\code{factor}). This should be an unquoted column name although this argument
is passed by expression and supports quasiquotation (you can unquote
column names). For \verb{_vec()} functions, a factor vector.}

\item{n_bins}{Number of bins to discretize the \verb{[0,1]} interval. Default is
10.}

\item{scale_estimate}{A \code{logical} value indicating whether \code{estimate} should
be normalised into the \verb{[0,1]} interval.}

\item{discretise_strategy}{Strategy used to define the widths of the bins
which is either 'uniform' (default) or 'quantile'. If 'uniform', the bins
have idential widths. If 'quantile', the bins have the same number of
samples.}

\item{na_rm}{A \code{logical} value indicating whether NA values should be
stripped before the computation proceeds.}

\item{estimate}{The column identifier for the predicted results (that is also
\code{numeric}). As with \code{truth} this can be specified different ways but the
primary method is to use an unquoted variable name. For \verb{_vec()}
functions, a \code{numeric} vector.}

\item{object}{The \code{clbr_df} data frame returned from \code{calibration_curve()}}
}
\value{
A tibble with \code{clbr_df} or \code{clbr_grouped_df} having columns \code{.frac_positive}
and \code{.mean_predicted}
}
\description{
\code{calibration_curve()} computes the true and predicted probabilities for a
calibration curve.
}
\details{
The function takes on inputs coming from a binary classifier.

Calibration curve is also known as reliability diagram. This function is
named as so to be akin to scikit-learn's calibration_curve method.

Quotes from Niculescu-Mizil & Caruana (2005) with minor modifications: First,
the predicted values (probabilities) is discretized into ten bins (default,
can be changed). Cases with predicted values between 0 and 0.1 fall in the
first bin, between 0.1 and 0.2 in the second bin, etc. For each bin, the mean
predicted value is plotted against the true fraction of positive cases.

There is a \code{\link[ggplot2:autoplot]{ggplot2::autoplot()}} method for quickly visualising the curve.
This works for binary and multiclass output, and also works with grouped data
(i.e. from resamples).
}
\section{Multiclass}{


If a multiclass \code{truth} column is provided, a one-vs-all
approach will be taken to calculate multiple curves, one per level.
In this case, there will be an additional column, \code{.level},
identifying the "one" column in the one-vs-all calculation.
}

\section{Relevant Level}{


There is no common convention on which factor level should
automatically be considered the "event" or "positive" result.
In \code{yardstick}, the default is to use the \emph{first} level. To
change this, a global option called \code{yardstick.event_first} is
set to \code{TRUE} when the package is loaded. This can be changed
to \code{FALSE} if the \emph{last} level of the factor is considered the
level of interest by running: \code{options(yardstick.event_first = FALSE)}.
For multiclass extensions involving one-vs-all
comparisons (such as macro averaging), this option is ignored and
the "one" level is always the relevant result.
}

\examples{

\dontrun{

library(dplyr)
library(ggplot2)

data("two_class_example", package = "yardstick")

two_class_example \%>\%
    calibration_curve(truth, Class1)

two_class_example \%>\%
   calibration_curve(truth, Class1) \%>\%
   autoplot()

}

}
\author{
An Chu
}
\concept{curve metrics}
